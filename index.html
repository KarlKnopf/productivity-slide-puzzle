<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Productivity Sliding Puzzle</title>
<style>
  body {
    font-family: sans-serif;
    display: flex;
    flex-direction: column;
    align-items: center;
    margin: 10px;
  }

  #controls {
    margin-bottom: 15px;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 5px;
  }

  #puzzle-container {
    display: grid;
    gap: 2px;
    width: 90vw;
    max-width: 400px;
    aspect-ratio: 1;
    touch-action: manipulation;
  }

  .tile {
    background-size: cover;
    background-position: center;
    cursor: pointer;
    width: 100%;
    height: 100%;
    display: flex;
    justify-content: center;
    align-items: center;
    font-weight: bold;
    color: white;
    user-select: none;
    border-radius: 4px;
  }

  #moves, #timer, #score {
    margin: 3px;
    font-weight: bold;
  }

  button, select {
    padding: 8px 12px;
    margin: 2px;
    cursor: pointer;
  }

  @media (max-width: 500px) {
    #controls {
      width: 90vw;
    }
  }
</style>
</head>
<body>

<div id="controls">
  <input type="file" id="imageInput" accept="image/*" multiple>
  <select id="difficultySelect">
    <option value="4">Normal (4x4)</option>
    <option value="5">Hard (5x5)</option>
  </select>
  <button id="startButton">Start Puzzle</button>
  <div id="moves">Moves left: 0</div>
  <div id="timer">Timer: 25:00</div>
  <div id="score">Puzzles solved: 0</div>
</div>

<div id="puzzle-container"></div>

<script>
let PUZZLE_SIZE = parseInt(localStorage.getItem('difficulty')) || 4;
const MOVES_PER_SESSION = 30;
let movesLeft = parseInt(localStorage.getItem('movesLeft')) || 0;
let carryoverMoves = parseInt(localStorage.getItem('carryoverMoves')) || 0;
let puzzle = [];
let emptyPos = {x: PUZZLE_SIZE-1, y: PUZZLE_SIZE-1};
let images = JSON.parse(localStorage.getItem('images')) || [];
let currentImageIndex = parseInt(localStorage.getItem('currentImageIndex')) || 0;
let timer = 25 * 60;
let timerInterval;
let puzzlesSolved = parseInt(localStorage.getItem('puzzlesSolved')) || 0;

const puzzleContainer = document.getElementById('puzzle-container');
const movesDisplay = document.getElementById('moves');
const timerDisplay = document.getElementById('timer');
const scoreDisplay = document.getElementById('score');
const imageInput = document.getElementById('imageInput');
const startButton = document.getElementById('startButton');
const difficultySelect = document.getElementById('difficultySelect');

difficultySelect.value = PUZZLE_SIZE;

imageInput.addEventListener('change', e => {
    const files = e.target.files;
    if (!files.length) return;
    images = [];
    for (const file of files) {
        const reader = new FileReader();
        reader.onload = function(event) {
            images.push(event.target.result);
            localStorage.setItem('images', JSON.stringify(images));
        }
        reader.readAsDataURL(file);
    }
    currentImageIndex = 0;
    localStorage.setItem('currentImageIndex', currentImageIndex);
});

difficultySelect.addEventListener('change', () => {
    PUZZLE_SIZE = parseInt(difficultySelect.value);
    localStorage.setItem('difficulty', PUZZLE_SIZE);
});

startButton.addEventListener('click', () => {
    if (!images.length) {
        alert('Please select at least one image first.');
        return;
    }
    loadCurrentImage(initPuzzle);
    startTimer();
});

function loadCurrentImage(callback) {
    const imgSrc = images[currentImageIndex];
    img = new Image();
    img.onload = callback;
    img.src = imgSrc;
}

function initPuzzle() {
    puzzle = [];
    puzzleContainer.innerHTML = '';
    puzzleContainer.style.gridTemplateColumns = `repeat(${PUZZLE_SIZE}, 1fr)`;
    puzzleContainer.style.gridTemplateRows = `repeat(${PUZZLE_SIZE}, 1fr)`;

    for (let y = 0; y < PUZZLE_SIZE; y++) {
        puzzle[y] = [];
        for (let x = 0; x < PUZZLE_SIZE; x++) {
            if (x === PUZZLE_SIZE-1 && y === PUZZLE_SIZE-1) {
                puzzle[y][x] = null;
                continue;
            }
            const tile = document.createElement('div');
            tile.className = 'tile';
            tile.style.backgroundImage = `url(${img.src})`;
            tile.style.backgroundSize = `${PUZZLE_SIZE*100}% ${PUZZLE_SIZE*100}%`;
            tile.style.backgroundPosition = `${(-x * 100)}% ${(-y * 100)}%`;
            tile.dataset.x = x;
            tile.dataset.y = y;
            tile.addEventListener('click', () => moveTile(x, y));
            puzzleContainer.appendChild(tile);
            puzzle[y][x] = tile;
        }
    }
    emptyPos = {x: PUZZLE_SIZE-1, y: PUZZLE_SIZE-1};
    scramblePuzzle();
    updateMovesDisplay();
}

function scramblePuzzle() {
    let moves = 1000;
    while (moves > 0) {
        const neighbors = getNeighbors(emptyPos.x, emptyPos.y);
        const choice = neighbors[Math.floor(Math.random() * neighbors.length)];
        swapTiles(emptyPos, choice);
        emptyPos = {x: choice.x, y: choice.y};
        moves--;
    }
}

function getNeighbors(x, y) {
    const neighbors = [];
    if (x > 0) neighbors.push({x:x-1, y:y});
    if (x < PUZZLE_SIZE-1) neighbors.push({x:x+1, y:y});
    if (y > 0) neighbors.push({x:x, y:y-1});
    if (y < PUZZLE_SIZE-1) neighbors.push({x:x, y:y+1});
    return neighbors;
}

function moveTile(x, y) {
    if (movesLeft + carryoverMoves <= 0) {
        alert('Out of moves! Complete a 25-minute session to earn more.');
        return;
    }
    const dx = Math.abs(x - emptyPos.x);
    const dy = Math.abs(y - emptyPos.y);
    if ((dx + dy) === 1) {
        swapTiles({x, y}, emptyPos);
        emptyPos = {x, y};
        if (carryoverMoves > 0) carryoverMoves--;
        else movesLeft--;
        updateMovesDisplay();
        saveProgress();
        if (checkWin()) {
            puzzlesSolved++;
            scoreDisplay.textContent = `Puzzles solved: ${puzzlesSolved}`;
            saveProgress();
            alert('Puzzle Solved! Loading next image...');
            nextImagePuzzle();
        }
    }
}

function nextImagePuzzle() {
    currentImageIndex = (currentImageIndex + 1) % images.length;
    localStorage.setItem('currentImageIndex', currentImageIndex);
    loadCurrentImage(initPuzzle);
}

function swapTiles(pos1, pos2) {
    const temp = puzzle[pos1.y][pos1.x];
    puzzle[pos1.y][pos1.x] = puzzle[pos2.y][pos2.x];
    puzzle[pos2.y][pos2.x] = temp;

    if (puzzle[pos1.y][pos1.x]) puzzleContainer.appendChild(puzzle[pos1.y][pos1.x]);
    if (puzzle[pos2.y][pos2.x]) puzzleContainer.appendChild(puzzle[pos2.y][pos2.x]);
}

function updateMovesDisplay() {
    movesDisplay.textContent = `Moves left: ${movesLeft + carryoverMoves}`;
}

function startTimer() {
    if (timerInterval) clearInterval(timerInterval);
    timer = 25*60;
    timerInterval = setInterval(() => {
        timer--;
        const minutes = String(Math.floor(timer/60)).padStart(2,'0');
        const seconds = String(timer%60).padStart(2,'0');
        timerDisplay.textContent = `Timer: ${minutes}:${seconds}`;
        if (timer <= 0) {
            clearInterval(timerInterval);
            carryoverMoves += MOVES_PER_SESSION;
            alert(`25 minutes complete! You earned ${MOVES_PER_SESSION} moves.`);
            updateMovesDisplay();
            saveProgress();
        }
    }, 1000);
}

function checkWin() {
    for (let y = 0; y < PUZZLE_SIZE; y++) {
        for (let x = 0; x < PUZZLE_SIZE; x++) {
            if (x === PUZZLE_SIZE-1 && y === PUZZLE_SIZE-1) continue;
            const tile = puzzle[y][x];
            if (!tile) return false;
            if (parseInt(tile.dataset.x) !== x || parseInt(tile.dataset.y) !== y) return false;
        }
    }
    return true;
}

function saveProgress() {
    localStorage.setItem('movesLeft', movesLeft);
    localStorage.setItem('carryoverMoves', carryoverMoves);
    localStorage.setItem('puzzlesSolved', puzzlesSolved);
    localStorage.setItem('difficulty', PUZZLE_SIZE);
    localStorage.setItem('currentImageIndex', currentImageIndex);
    localStorage.setItem('images', JSON.stringify(images));
}
</script>

</body>
</html>
